httpPort: &httpPort 80
httpsPort: &httpsPort 443
tlsEnabled: &tlsEnabled false

deployment:
  replicas: 1
  # -- Additional initContainers (e.g. for setting file permission as shown below)
  initContainers: []
  # The "volume-permissions" init container is required if you run into permission issues.
  # Related issue: https://github.com/traefik/traefik-helm-chart/issues/396
  # - name: volume-permissions
  #   image: busybox:latest
  #   command: ["sh", "-c", "touch /data/acme.json; chmod -v 600 /data/acme.json"]
  #   volumeMounts:
  #     - name: data
  #       mountPath: /data

ingressRoute:
  dashboard:
    # -- Create an IngressRoute for the dashboard
    enabled: true
    # -- Additional ingressRoute annotations (e.g. for kubernetes.io/ingress.class)
    annotations: {}
    # -- Additional ingressRoute labels (e.g. for filtering IngressRoute by custom labels)
    labels: {}
    # -- The router match rule used for the dashboard ingressRoute
    matchRule: Host(`traefik.testcenter.domain.tld`)
    # -- The internal service used for the dashboard ingressRoute
    services:
      - name: api@internal
        kind: TraefikService
    # -- Specify the allowed entrypoints to use for the dashboard ingress route, (e.g. traefik, web, websecure).
    # By default, it's using traefik entrypoint, which is not exposed.
    # /!\ Do not expose your dashboard without any protection over the internet /!\
    entryPoints: ["websecure"]
    # -- Additional ingressRoute middlewares (e.g. for authentication)
    middlewares: []
    # -- TLS options (e.g. secret containing certificate)
    tls: {}

logs:
  general:
    # -- Set [logs format](https://doc.traefik.io/traefik/observability/logs/#format)
    format:  # @schema enum:["common", "json", null]; type:[string, null]; default: "common"
    # By default, the level is set to INFO.
    # -- Alternative logging levels are TRACE, DEBUG, INFO, WARN, ERROR, FATAL, and PANIC.
    level: "DEBUG"  # @schema enum:[TRACE,DEBUG,INFO,WARN,ERROR,FATAL,PANIC]; default: "INFO"
    # -- To write the logs into a log file, use the filePath option.
    filePath: ""
    # -- When set to true and format is common, it disables the colorized output.
    noColor: false

globalArguments:
  - "--global.checknewversion=false"
  - "--global.sendanonymoususage=false"

ports:
  web:
    exposedPort: *httpPort
#    redirections:
#      entryPoint:
#        to: websecure
#        scheme: https
  websecure:
    exposedPort: *httpsPort
    tls:
      enabled: *tlsEnabled

tlsOptions:
  default:
    sniStrict: false # set false to use self-signed certificates
    cipherSuites:
      - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
      - TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
      - TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
      - TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
      - TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
      - TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
      - TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
      - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
      - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
      - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    minVersion: VersionTLS12

persistence:
  enabled: true
  name: data
  accessMode: ReadWriteOnce
  size: 128Mi
  storageClass: standard
  path: /data
  annotations: {}

podSecurityContext:
  # /!\ When setting fsGroup, Kubernetes will recursively change ownership and
  # permissions for the contents of each volume to match the fsGroup. This can
  # be an issue when storing sensitive content like TLS Certificates /!\
  #fsGroup: 65532
  # -- Specifies the policy for changing ownership and permissions of volume contents to match the fsGroup.
  #fsGroupChangePolicy: "OnRootMismatch"

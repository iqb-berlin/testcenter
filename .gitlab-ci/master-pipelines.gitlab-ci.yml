#############################################################################
## 'MASTER' TARGETED PULL REQUESTS, COMMITS, (PRE)-RELEASE TAGS
#############################################################################

.master_pr_rules:
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "master"
    - if: $CI_COMMIT_TAG
      when: never

.master_pr_manual_rules:
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "master"
      when: manual
    - if: $CI_COMMIT_TAG
      when: never

.master_commit_rules:
  rules:
    - if: $CI_COMMIT_BRANCH && ($CI_COMMIT_BRANCH == "master") && ($CI_PIPELINE_SOURCE != "external_pull_request_event")
    - if: $CI_COMMIT_TAG
      when: never


check-master-pr-rules:
  stage: .pre
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .master_pr_rules, rules ]
  script:
    - echo $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME
    - echo $CI_COMMIT_TAG
    - if [ "$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME" != "master" ];
      then echo "pull request target branch is not 'master'";
      else echo "pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' == 'master'"; fi
    - if [ "$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME" == "master" ];
      then echo "pull request target branch is 'master'";
      else echo "pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' != 'master'"; fi
    - if [ -n "$CI_COMMIT_TAG" ];
      then echo "commit tag string length is nonzero";
      else echo "commit tag = '$CI_COMMIT_TAG'"; fi
    - if [ -z "$CI_COMMIT_TAG" ];
      then echo "commit tag string length is zero";
      else echo "commit tag = '$CI_COMMIT_TAG'"; fi

check-master-commit-rules:
  stage: .pre
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .master_commit_rules, rules ]
  script:
    - echo $CI_COMMIT_BRANCH
    - echo $CI_PIPELINE_SOURCE
    - echo $CI_COMMIT_TAG
    - if [ -n "$CI_COMMIT_BRANCH" ];
      then echo "commit branch string length is nonzero";
      else echo "commit branch = '$CI_COMMIT_BRANCH'"; fi
    - if [ -z "$CI_COMMIT_BRANCH" ];
      then echo "commit branch string length is zero";
      else echo "commit branch = '$CI_COMMIT_BRANCH'"; fi
    - if [ "$CI_COMMIT_BRANCH" = "master" ];
      then echo "commit branch is 'master'";
      else echo "'$CI_COMMIT_BRANCH' != 'master'"; fi
    - if [ "$CI_COMMIT_BRANCH" != "master" ];
      then echo "commit branch is not 'master'";
      else echo "'$CI_COMMIT_BRANCH' == 'master'"; fi
    - if [ "$CI_PIPELINE_SOURCE" = "external_pull_request_event" ];
      then echo "pipeline source is 'external_pull_request_event'";
      else echo "'$CI_PIPELINE_SOURCE' != 'external_pull_request_event'"; fi
    - if [ "$CI_PIPELINE_SOURCE" != "external_pull_request_event" ];
      then echo "pipeline source is not 'external_pull_request_event'";
      else echo "'$CI_PIPELINE_SOURCE' == 'external_pull_request_event'"; fi
    - if [ -n "$CI_COMMIT_BRANCH" ] && [ "$CI_COMMIT_BRANCH" = "master" ] && [ "$CI_PIPELINE_SOURCE" = "external_pull_request_event" ];
      then echo "commit branch exists, is 'master', and it's an external_pull_request_event";
      else echo "commit branch = '$CI_COMMIT_BRANCH', pipeline source = '$CI_PIPELINE_SOURCE'"; fi
    - if [ -z "$CI_COMMIT_BRANCH" ] || [ "$CI_COMMIT_BRANCH" != "master" ] || [ "$CI_PIPELINE_SOURCE" != "external_pull_request_event" ];
      then echo "commit branch doesn't exist or isn't 'master' or it isn't an external_pull_request_event";
      else echo "commit branch = '$CI_COMMIT_BRANCH', pipeline source = '$CI_PIPELINE_SOURCE'"; fi
    - if [ -z "$CI_COMMIT_TAG" ];
      then echo "commit tag string length is zero";
      else echo "commit tag = '$CI_COMMIT_TAG'"; fi
    - if [ -n "$CI_COMMIT_TAG" ];
      then echo "commit tag string length is nonzero";
      else echo "commit tag = '$CI_COMMIT_TAG'"; fi


build-backend:
  stage: build
  rules:
    - !reference [ .master_pr_rules, rules ]
#    - !reference [ .backend-change, rules ]
#    - if: $CI_PIPELINE_SOURCE == "external_pull_request_event" || $CI_PIPELINE_SOURCE == "web"
#    - if: "$CI_COMMIT_TAG"
#    - changes:
#        - e2e/**/*
  variables:
    BACKEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-backend"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login
      --username $CI_DEPENDENCY_PROXY_USER --password $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login --username $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
        --progress plain
        --pull
        --target dev
        --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
        --build-arg BUILDKIT_INLINE_CACHE=1
        --cache-from ${BACKEND_IMAGE_NAME}:dev
        --file backend/Dockerfile
        --tag ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
        --tag ${BACKEND_IMAGE_NAME}:dev
      .
    - docker push --quiet --all-tags ${BACKEND_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

build-frontend:
  stage: build
  rules:
    - !reference [ .master_pr_rules, rules ]
#    - !reference [ .frontend-change, rules ]
#    - if: $CI_PIPELINE_SOURCE == "external_pull_request_event" || $CI_PIPELINE_SOURCE == "web"
#    - if: "$CI_COMMIT_TAG"
#    - changes:
#        - e2e/**/*
  variables:
    FRONTEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-frontend"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - cp frontend/src/environments/environment.dev.ts frontend/src/environments/environment.ts
    - docker login
      --username $CI_DEPENDENCY_PROXY_USER --password $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login --username $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
        --progress plain
        --pull
        --target dev
        --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
        --build-arg BUILDKIT_INLINE_CACHE=1
        --cache-from ${FRONTEND_IMAGE_NAME}:dev
        --file frontend/Dockerfile
        --tag ${FRONTEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
        --tag ${FRONTEND_IMAGE_NAME}:dev
      .
    - docker push --quiet --all-tags ${FRONTEND_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

build-broadcasting-service:
  stage: build
  rules:
    - !reference [ .master_pr_rules, rules ]
#    - !reference [ .bs-change, rules ]
#    - if: $CI_PIPELINE_SOURCE == "external_pull_request_event" || $CI_PIPELINE_SOURCE == "web"
#    - if: "$CI_COMMIT_TAG"
#    - changes:
#        - e2e/**/*
  variables:
    BROADCASTING_SERVICE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-broadcasting-service"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login
      --username $CI_DEPENDENCY_PROXY_USER --password $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login --username $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
        --progress plain
        --pull
        --target dev
        --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
        --build-arg BUILDKIT_INLINE_CACHE=1
        --cache-from ${BROADCASTING_SERVICE_IMAGE_NAME}:dev
        --file broadcasting-service/Dockerfile
        --tag ${BROADCASTING_SERVICE_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
        --tag ${BROADCASTING_SERVICE_IMAGE_NAME}:dev
      .
    - docker push --quiet --all-tags ${BROADCASTING_SERVICE_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

build-file-service:
  stage: build
  rules:
    - !reference [ .master_pr_rules, rules ]
#    - !reference [ .fs-change, rules ]
#    - if: $CI_PIPELINE_SOURCE == "external_pull_request_event" || $CI_PIPELINE_SOURCE == "web"
#    - if: "$CI_COMMIT_TAG"
#    - changes:
#        - e2e/**/*
  variables:
    FILE_SERVICE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-file-service"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login
        --username $CI_DEPENDENCY_PROXY_USER --password $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login --username $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${FILE_SERVICE_IMAGE_NAME}:dev
          --file file-service/Dockerfile
          --tag ${FILE_SERVICE_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
          --tag ${FILE_SERVICE_IMAGE_NAME}:dev
      .
    - docker push --quiet --all-tags ${FILE_SERVICE_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

build-e2e:
  stage: build
  rules:
    - !reference [ .master_pr_rules, rules ]
  variables:
    E2E_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/testcenter-e2e"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login
      --username $CI_DEPENDENCY_PROXY_USER --password $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login --username $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
        --progress plain
        --pull
        --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
        --build-arg BUILDKIT_INLINE_CACHE=1
        --cache-from ${E2E_IMAGE_NAME}:latest
        --file e2e/Dockerfile
        --tag ${E2E_IMAGE_NAME}:${CI_COMMIT_SHA}
        --tag ${E2E_IMAGE_NAME}:latest
      .
    - docker push --quiet --all-tags ${E2E_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

build-task-runner:
  stage: build
  rules:
    - !reference [ .master_pr_rules, rules ]
  variables:
    TASK_RUNNER_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/task-runner"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login
      --username $CI_DEPENDENCY_PROXY_USER --password $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login --username $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
        --progress plain
        --pull
        --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
        --build-arg BUILDKIT_INLINE_CACHE=1
        --cache-from ${TASK_RUNNER_IMAGE_NAME}:latest
        --file task-runner/Dockerfile
        --tag ${TASK_RUNNER_IMAGE_NAME}:${CI_COMMIT_SHA}
        --tag ${TASK_RUNNER_IMAGE_NAME}:latest
      .
    - docker push --quiet --all-tags ${TASK_RUNNER_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

test-backend-unit:
  stage: test
  rules:
    - !reference [ .master_pr_rules, rules ]
#    - !reference [ .backend-change, rules ]
#    - if: $CI_PIPELINE_SOURCE == "external_pull_request_event" || $CI_PIPELINE_SOURCE == "web"
#    - if: "$CI_COMMIT_TAG"
  needs:
    - build-backend
  variables:
    BACKEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-backend"
  before_script:
    - cp docker/default.env docker/.env
    - chmod 0755 scripts/database/000-create-test-db.sh
    - docker pull --quiet ${DOCKERHUB_PROXY}mysql:8.0
    - docker pull --quiet ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
    - docker tag ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev iqbberlin/testcenter-backend:current
  script:
    - docker compose
          --file docker/docker-compose.yml
          --file docker/docker-compose.dev.yml
        run --rm --entrypoint "" testcenter-backend php -dxdebug.mode='coverage'
          /var/www/testcenter/backend/vendor/phpunit/phpunit/phpunit
            --bootstrap /var/www/testcenter/backend/test/unit/bootstrap.php
            --configuration /var/www/testcenter/backend/phpunit.xml
            --coverage-html /docs/dist/test-coverage-backend-unit /var/www/testcenter/backend/test/unit/
            --testdox
  artifacts:
    paths:
      - docs/dist/test-coverage-backend-unit/*
    expire_in: 30 minutes

test-frontend-unit:
  stage: test
  rules:
    - !reference [ .master_pr_rules, rules ]
#    - !reference [ .frontend-change, rules ]
#    - if: $CI_PIPELINE_SOURCE == "external_pull_request_event" || $CI_PIPELINE_SOURCE == "web"
#    - if: "$CI_COMMIT_TAG"
  needs:
    - build-frontend
  variables:
    FRONTEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-frontend"
  before_script:
    - cp docker/default.env docker/.env
    - cp frontend/src/environments/environment.dev.ts frontend/src/environments/environment.ts
    - docker pull --quiet ${FRONTEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
    - docker tag ${FRONTEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev iqbberlin/testcenter-frontend:current
  script:
    - docker compose
          --file docker/docker-compose.yml
          --file docker/docker-compose.dev.yml
        run testcenter-frontend npx ng test --watch=false --code-coverage
  artifacts:
    paths:
      - docs/dist/test-coverage-frontend-unit/*
    expire_in: 30 minutes

test-broadcasting-service-unit:
  stage: test
  rules:
    - !reference [ .master_pr_rules, rules ]
#    - !reference [ .bs-change, rules ]
#    - if: "$CI_COMMIT_TAG"
  needs:
    - build-broadcasting-service
  variables:
    BROADCASTING_SERVICE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-broadcasting-service"
  before_script:
    - cp docker/default.env docker/.env
    - docker pull --quiet ${BROADCASTING_SERVICE_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
    - docker tag
        ${BROADCASTING_SERVICE_IMAGE_NAME}:${CI_COMMIT_SHA}_dev iqbberlin/testcenter-broadcasting-service:current
  script:
    - docker compose
          --file docker/docker-compose.yml
          --file docker/docker-compose.dev.yml
        run testcenter-broadcasting-service npx jest --coverage
  artifacts:
    paths:
      - docs/dist/test-coverage-broadcasting-service-unit/*
    expire_in: 30 minutes

test-backend-api:
  stage: test
  rules:
    - !reference [ .master_pr_rules, rules ]
#    - !reference [ .backend-change, rules ]
#    - if: $CI_PIPELINE_SOURCE == "external_pull_request_event" || $CI_PIPELINE_SOURCE == "web"
#    - if: "$CI_COMMIT_TAG"
  needs:
    - build-backend
    - build-task-runner
  variables:
    BACKEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-backend"
    TASK_RUNNER_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/task-runner"
  before_script:
    - cp docker/default.env docker/.env
    - chmod 0755 scripts/database/000-create-test-db.sh
    - docker pull --quiet ${DOCKERHUB_PROXY}mysql:8.0
    - docker pull --quiet ${DOCKERHUB_PROXY}redis:7.0-bullseye
    - docker pull --quiet ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
    - docker tag ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev iqbberlin/testcenter-backend:current
    - docker pull --quiet ${TASK_RUNNER_IMAGE_NAME}:${CI_COMMIT_SHA}
    - docker tag ${TASK_RUNNER_IMAGE_NAME}:${CI_COMMIT_SHA} docker-testcenter-task-runner-backend
  script:
    - docker compose
          --file docker/docker-compose.yml
          --file docker/docker-compose.dev.yml
          --file docker/docker-compose.api-test.yml
        run --rm testcenter-task-runner-backend npm run backend:api-test

test-file-service-api:
  stage: test
  rules:
    - !reference [ .master_pr_rules, rules ]
#    - !reference [ .fs-change, rules ]
#    - if: $CI_PIPELINE_SOURCE == "external_pull_request_event" || $CI_PIPELINE_SOURCE == "web"
#    - if: "$CI_COMMIT_TAG"
  needs:
    - build-file-service
    - build-task-runner
  variables:
    FILE_SERVICE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-file-service"
    TASK_RUNNER_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/task-runner"
  before_script:
    - cp docker/default.env docker/.env
    - docker pull --quiet ${DOCKERHUB_PROXY}redis:7.0-bullseye
    - docker pull --quiet ${FILE_SERVICE_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
    - docker tag ${FILE_SERVICE_IMAGE_NAME}:${CI_COMMIT_SHA}_dev iqbberlin/testcenter-file-service:current
    - docker pull --quiet ${TASK_RUNNER_IMAGE_NAME}:${CI_COMMIT_SHA}
    - docker tag ${TASK_RUNNER_IMAGE_NAME}:${CI_COMMIT_SHA} docker-testcenter-task-runner-file-service
  script:
    - docker compose
          -f docker/docker-compose.yml
          -f docker/docker-compose.dev.yml
          -f docker/docker-compose.api-test.yml
        run --rm testcenter-task-runner-file-service npm run file-service:api-test

test-backend-initialization:
  stage: test
  rules:
    - !reference [ .master_pr_rules, rules ]
#    - if: $CI_PIPELINE_SOURCE == "external_pull_request_event" || $CI_PIPELINE_SOURCE == "web"
#    - if: "$CI_COMMIT_TAG"
  needs:
    - build-backend
  variables:
    BACKEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-backend"
  before_script:
    - cp docker/default.env docker/.env
    - docker pull --quiet ${DOCKERHUB_PROXY}mysql:8.0
    - docker pull --quiet ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
    - docker tag ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev iqbberlin/testcenter-backend:dev
  script:
    - TEST_NAME=general/db-versions docker compose --file docker/docker-compose.initialization-test.yml
        up --force-recreate --renew-anon-volumes --abort-on-container-exit
    - TEST_NAME=general/vanilla-installation docker compose --file docker/docker-compose.initialization-test.yml
        up --force-recreate --renew-anon-volumes --abort-on-container-exit
    - TEST_NAME=general/no-db-but-files docker compose --file docker/docker-compose.initialization-test.yml
        up --force-recreate --renew-anon-volumes --abort-on-container-exit
    - TEST_NAME=general/install-db-patches docker compose --file docker/docker-compose.initialization-test.yml
        up --force-recreate --renew-anon-volumes --abort-on-container-exit
    - TEST_NAME=general/re-initialize docker compose --file docker/docker-compose.initialization-test.yml
        up --force-recreate --renew-anon-volumes --abort-on-container-exit

test-e2e:
  stage: test
  allow_failure: true
  rules:
    - !reference [ .master_pr_rules, rules ]
#    - if: $CI_PIPELINE_SOURCE == "external_pull_request_event" || $CI_PIPELINE_SOURCE == "web"
#    - if: "$CI_COMMIT_TAG"
#    - !reference [ .frontend-change, rules ]
#    - changes:
#        - e2e/**/*
  needs:
    - build-backend
    - build-frontend
    - build-broadcasting-service
    - build-file-service
    - build-e2e
  variables:
    BACKEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-backend"
    FRONTEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-frontend"
    BROADCASTING_SERVICE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-broadcasting-service"
    FILE_SERVICE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-file-service"
    E2E_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/testcenter-e2e"
  before_script:
    - cp docker/default.env docker/.env
    - cp frontend/src/environments/environment.dev.ts frontend/src/environments/environment.ts
    - chmod 0755 scripts/database/000-create-test-db.sh
    - docker pull --quiet ${DOCKERHUB_PROXY}traefik:v2.10
    - docker pull --quiet ${DOCKERHUB_PROXY}mysql:8.0
    - docker pull --quiet ${DOCKERHUB_PROXY}redis:7.0-bullseye
    - docker pull --quiet ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
    - docker tag ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev iqbberlin/testcenter-backend:current
    - docker pull --quiet ${BROADCASTING_SERVICE_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
    - docker pull --quiet ${FRONTEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
    - docker tag ${FRONTEND_IMAGE_NAME}:${CI_COMMIT_SHA}_dev iqbberlin/testcenter-frontend:current
    - docker pull --quiet ${BROADCASTING_SERVICE_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
    - docker tag
        ${BROADCASTING_SERVICE_IMAGE_NAME}:${CI_COMMIT_SHA}_dev iqbberlin/testcenter-broadcasting-service:current
    - docker pull --quiet ${FILE_SERVICE_IMAGE_NAME}:${CI_COMMIT_SHA}_dev
    - docker tag ${FILE_SERVICE_IMAGE_NAME}:${CI_COMMIT_SHA}_dev iqbberlin/testcenter-file-service:current
    - docker pull --quiet ${E2E_IMAGE_NAME}:${CI_COMMIT_SHA}
    - docker tag ${E2E_IMAGE_NAME}:${CI_COMMIT_SHA} docker-testcenter-e2e
  script:
    - docker compose
          --file docker/docker-compose.yml
          --file docker/docker-compose.dev.yml
          --file docker/docker-compose.system-test-headless.yml
        up --abort-on-container-exit --exit-code-from=testcenter-e2e
  artifacts:
    when: always
    paths:
      - e2e/cypress/videos/**/*.mp4
      - e2e/cypress/screenshots/**/*.png


build-backend-prod:
  stage: build
  rules:
    - !reference [ .master_commit_rules, rules ]
  #    - if: "$CI_COMMIT_TAG"
  variables:
    BACKEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-backend"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login
        --username $CI_DEPENDENCY_PROXY_USER --password $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login --username $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${BACKEND_IMAGE_NAME}:latest
          --file backend/Dockerfile
          --tag ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}
          --tag ${BACKEND_IMAGE_NAME}:latest
        .
    - docker push --quiet --all-tags ${BACKEND_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

build-frontend-prod:
  stage: build
  rules:
    - !reference [ .master_commit_rules, rules ]
#    - if: "$CI_COMMIT_TAG"
  variables:
    FRONTEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-frontend"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - cp frontend/src/environments/environment.dev.ts frontend/src/environments/environment.ts
    - docker login
        --username $CI_DEPENDENCY_PROXY_USER --password $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login --username $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${FRONTEND_IMAGE_NAME}:latest
          --file frontend/Dockerfile
          --tag ${FRONTEND_IMAGE_NAME}:${CI_COMMIT_SHA}
          --tag ${FRONTEND_IMAGE_NAME}:latest
        .
    - docker push --quiet --all-tags ${FRONTEND_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

build-broadcasting-service-prod:
  stage: build
  rules:
    - !reference [ .master_commit_rules, rules ]
#    - if: "$CI_COMMIT_TAG"
  variables:
    BROADCASTING_SERVICE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-broadcasting-service"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login
      --username $CI_DEPENDENCY_PROXY_USER --password $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login --username $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${BROADCASTING_SERVICE_IMAGE_NAME}:latest
          --file broadcasting-service/Dockerfile
          --tag ${BROADCASTING_SERVICE_IMAGE_NAME}:${CI_COMMIT_SHA}
          --tag ${BROADCASTING_SERVICE_IMAGE_NAME}:latest
        .
    - docker push --quiet --all-tags ${BROADCASTING_SERVICE_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

build-file-service-prod:
  stage: build
  rules:
    - !reference [ .master_commit_rules, rules ]
#    - if: "$CI_COMMIT_TAG"
  variables:
    FILE_SERVICE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-file-service"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login
        --username $CI_DEPENDENCY_PROXY_USER --password $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login --username $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${FILE_SERVICE_IMAGE_NAME}:latest
          --file file-service/Dockerfile
          --tag ${FILE_SERVICE_IMAGE_NAME}:${CI_COMMIT_SHA}
          --tag ${FILE_SERVICE_IMAGE_NAME}:latest
        .
    - docker push --quiet --all-tags ${FILE_SERVICE_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

scan-backend-prod:
  stage: test
  allow_failure: true
  rules:
    - !reference [ .master_commit_rules, rules ]
#    - if: "$CI_COMMIT_TAG"
  needs:
    - build-backend-prod
  image:
    name: $TRIVY_IMAGE
    entrypoint: [ "" ]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-backend:${CI_COMMIT_SHA}"
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - trivy clean --scan-cache
    # update vulnerabilities db
    - trivy image --download-db-only --no-progress
    # Builds report and puts it in the default workdir $CI_PROJECT_DIR, so `artifacts:` can take it from there
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
          --format template
          --template "@/contrib/gitlab.tpl"
          --output "$CI_PROJECT_DIR/gl-container-scanning-report.json"
        "$FULL_IMAGE_NAME"
    # Prints full report
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
        "$FULL_IMAGE_NAME"
    # Fail on critical vulnerabilities
    - trivy image
          --exit-code 1
          --timeout 30m
          --scanners vuln
          --ignore-unfixed
          --severity CRITICAL
        "$FULL_IMAGE_NAME"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json

scan-frontend-prod:
  stage: test
  allow_failure: true
  rules:
    - !reference [ .master_commit_rules, rules ]
  #    - if: "$CI_COMMIT_TAG"
  needs:
    - build-frontend-prod
  image:
    name: $TRIVY_IMAGE
    entrypoint: [ "" ]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-frontend:${CI_COMMIT_SHA}"
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - trivy clean --scan-cache
    # update vulnerabilities db
    - trivy image --download-db-only --no-progress
    # Builds report and puts it in the default workdir $CI_PROJECT_DIR, so `artifacts:` can take it from there
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
          --format template
          --template "@/contrib/gitlab.tpl"
          --output "$CI_PROJECT_DIR/gl-container-scanning-report.json"
        "$FULL_IMAGE_NAME"
    # Prints full report
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
        "$FULL_IMAGE_NAME"
    # Fail on critical vulnerabilities
    - trivy image
          --exit-code 1
          --timeout 30m
          --scanners vuln
          --ignore-unfixed
          --severity CRITICAL
        "$FULL_IMAGE_NAME"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json

scan-broadcasting-service-prod:
  stage: test
  allow_failure: true
  rules:
    - !reference [ .master_commit_rules, rules ]
  #    - if: "$CI_COMMIT_TAG"
  needs:
    - build-broadcasting-service-prod
  image:
    name: $TRIVY_IMAGE
    entrypoint: [ "" ]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-broadcasting-service:${CI_COMMIT_SHA}"
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - trivy clean --scan-cache
    # update vulnerabilities db
    - trivy image --download-db-only --no-progress
    # Builds report and puts it in the default workdir $CI_PROJECT_DIR, so `artifacts:` can take it from there
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
          --format template
          --template "@/contrib/gitlab.tpl"
          --output "$CI_PROJECT_DIR/gl-container-scanning-report.json"
        "$FULL_IMAGE_NAME"
    # Prints full report
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
        "$FULL_IMAGE_NAME"
    # Fail on critical vulnerabilities
    - trivy image
          --exit-code 1
          --timeout 30m
          --scanners vuln
          --ignore-unfixed
          --severity CRITICAL
        "$FULL_IMAGE_NAME"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json

scan-file-service-prod:
  stage: test
  allow_failure: true
  rules:
    - !reference [ .master_commit_rules, rules ]
  #    - if: "$CI_COMMIT_TAG"
  needs:
    - build-file-service-prod
  image:
    name: $TRIVY_IMAGE
    entrypoint: [ "" ]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/testcenter-file-service:${CI_COMMIT_SHA}"
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - trivy clean --scan-cache
    # update vulnerabilities db
    - trivy image --download-db-only --no-progress
    # Builds report and puts it in the default workdir $CI_PROJECT_DIR, so `artifacts:` can take it from there
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
          --format template
          --template "@/contrib/gitlab.tpl"
          --output "$CI_PROJECT_DIR/gl-container-scanning-report.json"
        "$FULL_IMAGE_NAME"
    # Prints full report
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
        "$FULL_IMAGE_NAME"
    # Fail on critical vulnerabilities
    - trivy image
          --exit-code 1
          --timeout 30m
          --scanners vuln
          --ignore-unfixed
          --severity CRITICAL
        "$FULL_IMAGE_NAME"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json

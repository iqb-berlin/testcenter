<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple Verona Player 6.0</title>

  <script type="application/ld+json">
    {
      "$schema": "https://raw.githubusercontent.com/verona-interfaces/metadata/master/verona-module-metadata.json",
      "type": "player",
      "id": "verona-player-simple",
      "name": [
        {
          "value": "Simple HTML Player",
          "lang": "en"
        }
      ],
      "version": "6.0.4",
      "specVersion": "6.0",
      "description": [
        {
          "value": "This is a simple, dependency-less, vanilla-js-written, but full-featured unit player, mainly as showcase for developers and for software-testing. It does implement the Verona 4.0.0-Standard and can be used for units containing simple any content in HTML-format. Unit Description ist the <code>form</code>-content as HTML. Just give some names to the form element, and the player does the rest. Use some special Ids for some special buttons.",
          "lang": "en"
        }
      ],
      "maintainer": {
        "name": [
          {
            "value": "IQB - Institute for Educational Quality Improvement",
            "lang": "en"
          }
        ],
        "email": "iqb-tbadev@hu-berlin.de",
        "url": "https://www.iqb.hu-berlin.de"
      },
      "code": {
        "repositoryUrl": "https://github.com/iqb-berlin/verona-player-simple",
        "repositoryType": "git",
        "licenseType": "MIT",
        "licenseUrl": "https://raw.githubusercontent.com/iqb-berlin/verona-player-simple/main/LICENSE"
      },
      "metadataVersion": "2.0"
    }
  </script>

  <style>
    html, body {
      height: 100vh;
      overflow: hidden;
      font-family: sans-serif;
      margin: 0;
    }

    #unit {
      overflow: auto;
      height: 100vh;
      margin: 0 9em;
    }

    #unit.paged.buttons,
    #unit.paged.separate {
      overflow-y: auto;
      height: 100vh;
    }

    #unit.paged fieldset:first-of-type {
      display: block
    }

    #unit.paged.buttons fieldset,
    #unit.paged.separate fieldset {
      overflow-y: auto;
      height: calc(100% - 100px);
      padding: 50px 0;
      border: 0;
    }

    /* add some whitespace in scrollmode, to make it possible to get last pages on the top even if they are small */
    #unit.paged.concat-scroll:after,
    #unit.paged.concat-scroll-snap:after {
      height: 100%;
      display: block;
      content: " ";
    }

    #unit.concat-scroll-snap {
      scroll-snap-type: y proximity;
    }

    #unit.concat-scroll-snap fieldset {
      scroll-snap-align: start;
    }

    .page-bottom-anchor {
      display: block;
      height: 50px;
    }

    .vsp-navigation-tier {
      position: fixed;
    }

    .vsp-navigation-tier button {
      padding: 2px 6px;
      cursor: pointer;
    }

    .vsp-navigation-tier button,
    vsp-namehint,
    vsp-message {
      border: none;
      border-radius: 2px;
      box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.75);
      background: rgba(0, 0, 0, 0.75);
      color: white;
      font-size: small;
    }

    vsp-namehint {
      padding: 1px;
    }

    vsp-message {
      position: fixed;
      display: none;
      max-height: 300px;
      right: 20px;
      top: 20px;
      padding: 10px;
      width: 300px;
      filter: blur(4px);
      opacity: 0;
      transform: scale(2);
      transform-origin: center;
      animation: flyin 0.5s ease forwards;
    }

    vsp-message [onclick] {
      cursor: pointer;
    }

    vsp-message [onclick]:hover {
      text-decoration: underline;
      color: grey;
    }

    vsp-message.error {
      background: rgba(150, 0, 0, 0.75);
    }

    vsp-pointer {
      position: absolute;
      height: 30px;
      width: 30px;
    }

    vsp-pointer:after {
      position: relative;
      line-height: 25px;
      text-shadow: 0 0 5px rgba(0,0,0,0.75);
      display: inline-block;
      filter: blur(4px);
      opacity: 0;
      transform: scale(2);
      transform-origin: center;
      animation: flyin 0.5s ease forwards;
      font-size: 30px;
      content: "►";
    }

    vsp-message-close {
      position: absolute;
      right: 5px;
      top: 2px;
      cursor: pointer;
    }

    .vsp-navigation-tier button:hover,
    vsp-message-close:hover {
      color: grey
    }

    .vsp-navigation-tier button:disabled {
      box-shadow: 0 0 5px 0 rgba(100, 100, 100, 0.75);
      background: rgba(0, 0, 0, 0.75);
      color: grey;
      cursor: auto;
    }

    #vsp-meta dl dd {
      display: inline;
      margin: 0;
    }

    #vsp-meta dl dd:after {
      display: block;
      content: '';
    }

    #vsp-meta dl dt {
      display: inline-block;
      min-width: 250px;
    }

    @keyframes flyin {
      to {
        filter: blur(0);
        transform: scale(1);
        opacity: 1;
      }
    }
</style>
<style id="print-styles" media="print">
    @page {
      size: A4 landscape;
      margin: 15pt;
    }
    html, body, #unit.paged.separate, #unit.paged.buttons, #unit {
      height: auto;
    }
    vsp-message,
    .vsp-navigation-tier,
    #vsp-meta {
      display: none
    }

    a[href^="https://"]:after, a[href^="https://"]:after {
      content: " (" attr(href) ")";
    }

    video, audio, object, embed {
      content: " (" attr(href) ")";
      background: silver;
    }

    fieldset {
      display: block !important;
      height: auto !important;
      padding: 0 !important;
      break-after: page;
    }

    #unit {
      margin: 0;
    }
</style>
</head>
<body>

<div class="vsp-navigation-tier" style="width: 100%; text-align: center; top: 1em;">
  <button id="prev-page" data-cy="previous-unit-page" title="Previous Page" type="button" class="btn btn-outline-primary">↑</button>
</div>

<div class="vsp-navigation-tier" style="text-align: center; bottom: 1em; left: 9em; right: 9em; ">
  <button id="next-page" data-cy="next-unit-page" title="Next Page" type="button" class="btn btn-outline-primary">↓</button>
</div>

<div class="vsp-navigation-tier" style="top: 50%; left: 1em;">
  <button id="first-unit" title="First Unit" type="submit" class="btn btn-primary" value="first" name="target">⇤</button>
  <button id="prev-unit" title="Previous Unit" type="submit" class="btn btn-primary" value="previous" name="target">←</button>
</div>

<div class="vsp-navigation-tier" style="top: 50%; right: 1em;">
  <button id="next-unit" title="Next Unit" type="submit" class="btn btn-primary" value="next" name="target">→</button>
  <button id="last-unit" title="Last Unit" type="submit" class="btn btn-primary" value="last" name="target">⇥</button>
  <button id="end-unit" title="Finish" type="submit" class="btn btn-primary" value="end" name="target">▪</button>
</div>

<vsp-message>
  <vsp-message-content></vsp-message-content>
  <vsp-message-close>✖</vsp-message-close>
</vsp-message>

<form>
  <div id="unit"><!-- will be filled automatically --></div>
</form>

<script>
  const unitStateDataType = "iqb-standard@1.3";
  const unitDefinitionType = "verona-player-simple-6.0";

  // some polyfills
  (function polyfillReactionToProgrammaticallyChangedInputValue() {
    const descriptor = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, "value");
    const originalSet = descriptor.set;

    descriptor.set = function(val) {
      if (this.value !== val) {
        originalSet.apply(this, arguments);
        const event = new CustomEvent(
          'programmaticallyChange',
          {
            bubbles: true,
            detail: {
              from: this.value,
              to: val
            }
          }
        );
        this.dispatchEvent(event);
      }
    }

    Object.defineProperty(HTMLInputElement.prototype, "value", descriptor);
  }());

  // Player Settings
  // Some specific configs, that might be overridden in some test-contexts in two ways
  // a) when player is embedded with src, put then in url parameters
  // b) when player is embedded with srcdoc, the following line can be replaced;
  const overridePlayerSettings = location.search;

  const playerSettings = Object.assign(
    {
      debounceStateMessages: 50,
      debounceKeyboardEvents: 100,
      delayReadyNotification: 0
    },
    overridePlayerSettings
      .substring(1)
      .split("&")
      .reduce((carry, item) => {const tmp = item.split("="); carry[tmp[0]] = tmp[1]; return carry;}, {})
  );

  const playerMetaData = JSON.parse(document.querySelector('script[type="application/ld+json"]').innerText)

  const pagingModes = ["separate", "concat-scroll", "concat-scroll-snap", "buttons"];

  let playerConfig = {
    logPolicy: 'eager', // "disabled" | "lean" | "rich" | "debug"
    unitNumber: 0,
    unitTitle: 'Unit',
    unitId: 'unit',
    enabledNavigationTargets: [], // can contain  "next" "previous" "first" "last" "end"
    pagingMode: "buttons", // "separate" | "concat-scroll" | "concat-scroll-snap" | "buttons"
    printMode: "off",
    startPage: null,
    directDownloadUrl: null,
  }

  let sessionId = "";

  const isDefined = v => (typeof v !== "undefined");
  const isEmpty = object => {
    // noinspection LoopStatementThatDoesntLoopJS
    for(let property in object) return false;
    return true;
  }

  const Format = new class {
    parse = format => {
      const parts = format.match(/(^.+)[-@](\d+)(.(\d+))?(.(\d+))?(-(.+))?$/);
      return parts ? {
        format: parts[1] || format,
        major: parseInt(parts[2] || 0),
        minor: parseInt(parts[4] || 0),
        patch: parseInt(parts[6] || 0),
        label: parts[8] || ''
      } : format;
    }
    isSupportedBy = (format1, format2) => {
      const v1 = Format.parse(format1);
      const v2 = Format.parse(format2);
      if (v1.format !== v2.format) return false;
      if (v1.major !== v2.major) return false;
      return (v1.minor <= v2.minor);
    };
  }

  const Time = new class {
    throttle = (callback, limit) => {
      let waiting = false;
      return function () {
        if (waiting) return;
        callback.apply(this, arguments);
        waiting = true;
        setTimeout(() => {
          waiting = false;
        }, limit);
      }
    }

    debounce = (callback, limit, debounceCallback) => {
      let handle = null;
      return function () {
        if (typeof debounceCallback === "function") {
          debounceCallback.apply(this, arguments);
        }
        clearTimeout(handle);
        handle = setTimeout(() => {
          callback.apply(this, arguments);
        }, limit);
      }
    }
  }

  const Message = new class {
    send = new class {
      _lastStates = {
        playerState: null,
        unitState: null
      };

      vopStateChangedNotification = Time.debounce(
        () => {
          const message = this._createStateMsg();
          if (message.playerState || message.unitState || message.log) {
            this._send(message);
          }
        },
        parseInt(playerSettings.debounceStateMessages, 10),
        () => {
          document.dispatchEvent(new CustomEvent('queued:vopStateChangedNotification', {}))
        }
      );

      vopReadyNotification = () => {
        setTimeout(
          () => this._send({
            type: 'vopReadyNotification',
            metadata: playerMetaData
          }),
          playerSettings.delayReadyNotification
        )
      };

      vopUnitNavigationRequestedNotification = target => {
        this._send({
          type: 'vopUnitNavigationRequestedNotification',
          sessionId,
          target,
        });
      };

      vopWindowFocusChangedNotification = hasFocus => {
        this._send({
          type: 'vopWindowFocusChangedNotification',
          sessionId,
          hasFocus
        });
      }

      vopRuntimeErrorNotification = (code, message) => {
        this._send({
          type: 'vopRuntimeErrorNotification',
          sessionId,
          code,
          message
        })
      }

      _send = msg => {
        window.parent.postMessage(msg, '*');
        document.dispatchEvent(new CustomEvent('sent:' + msg.type, {detail: msg}));
      }

      _createStateMsg = (complete = false) => {
        const message = {
          type: 'vopStateChangedNotification',
          sessionId: sessionId,
          timeStamp: Date.now(),
        }

        const playerState = this._getPlayerState();
        if (complete || (JSON.stringify(playerState) !== JSON.stringify(this._lastStates.playerState))) {
          this._lastStates.playerState = playerState;
          if (!isEmpty(playerState)) {
            message.playerState = playerState;
          }
        }

        const unitState = this._getUnitState();
        if (complete || (JSON.stringify(unitState) !== JSON.stringify(this._lastStates.unitState))) {
          message.unitState = unitState;
          this._lastStates.unitState = unitState;
        }

        if (Log.hasNew()) {
          message.log = Log.next();
        }

        return message;
      }

      _getPlayerState = () => {
        const playerState = {};
        if (Pages.hasPages) {
          playerState.validPages = Object.keys(Pages.validPages).map(id => ({id, label: Pages.validPages[id]}))
          playerState.currentPage = Pages.currentPage.toString()
        }
        return playerState;
      }

      _getUnitState = () => ({
        dataParts: Unit.getData(),
        presentationProgress: Unit.getPresentationProgress(),
        responseProgress: Unit.getResponseProgress(),
        unitStateDataType
      });
    }

    receive = (type, data) => {
      if (type === "vopStartCommand") {
        Unit.start(data);
        document.dispatchEvent(new CustomEvent(type, { detail: data }));
      } else if (sessionId && (data.sessionId !== sessionId)) {
        throw new VspRuntimeError('wrong-session-id', `Wrong Session-Id: '${sessionId}' (was: '${sessionId}').`);
      } else if (sessionId) {
        document.dispatchEvent(new CustomEvent(type, { detail: data }));
      } else {
        console.warn(`Message before first vopStartCommand, ignored: ${type}`, data);
      }
    };
  }

  const Unit = new class {
    presentationProgress = 'none';
    responseProgress = 'none';

    dataPartsCollectors = {
      answers: () => Answers.get()
    };

    presentationProgressFactors = {
      pages: {
        complete: () => Object.values(Pages.seenPages).filter(p => p.enter && p.bottom).length === Pages.pageCount,
        some: () => Object.values(Pages.seenPages).filter(p => p.enter || p.bottom).length > 0
      }
    };

    responseProgressFactors = {
      elements: {
        complete: () => Answers.countValid() === Answers.countAll(),
        some: () => Answers.countValid() > 0,
      }
    }

    start = data => {
      if (!data.sessionId) {
        throw new VspRuntimeError("session-id-missing", "Session-Id is missing.");
      }
      sessionId = data.sessionId;
      if (!data.unitDefinition) {
        throw new VspRuntimeError("unit-definition-missing", "Unit-Definition is missing.")
      }


      if (data.unitDefinitionType &&
        !Format.isSupportedBy(data.unitDefinitionType, unitDefinitionType)
      ) {
        throw new VspRuntimeError(
          'unit-definition-type-unsupported',
          `Format of unit definition '${data.unitDefinitionType}' is not compatible with '${unitDefinitionType}'.`
        );
      }
      if (
        data.unitState && data.unitState.unitStateDataType &&
        !Format.isSupportedBy(data.unitState.unitStateDataType, unitStateDataType)
      ) {
        throw new VspRuntimeError(
          'unit-state-type-unsupported',
          `Format of UnitState '${data.unitState.unitStateDataType}' is not compatible with '${unitStateDataType}'.`
        );
      }

      this._setUnit(data.unitDefinition);
      this._setPlayerConfig(data.playerConfig || {});

      Answers.prepare();
      this._setUnitData(data.unitState || {});

      this.presentationProgress = data.unitState?.presentationProgress || 'none';
      this.responseProgress = data.unitState?.responseProgress || 'none';

      PlayerUI.togglePrintMode();
      PlayerUI.toggleUnitNavButtons();
      PlayerUI.togglePageNavButtons();
    };

    getData = () =>
      Object.keys(this.dataPartsCollectors)
        .reduce((carry, key) => {
          const dataPart = this.dataPartsCollectors[key]();
          carry[key] = (typeof dataPart !== 'string') ? JSON.stringify(dataPart) : dataPart;
          return carry;
        }, {});

    getPresentationProgress = () =>
      this.presentationProgress = this._highestProgress([
        this.presentationProgress,
        this._mergeProgressFactors(this.presentationProgressFactors)
      ]);

    getResponseProgress = () =>
      this.responseProgress = this._highestProgress([
        this.responseProgress,
        this._mergeProgressFactors(this.responseProgressFactors)
      ]);

    _highestProgress = progressValues => {
      return progressValues.includes('complete') ? 'complete' : (progressValues.includes('some') ? 'some' : 'none');
    }

    _mergeProgressFactors = progressFactors => Object.values(progressFactors)
      .map(factor => {
        if (factor.complete()) return 'complete';
        if (factor.some()) return 'some'
        return 'none';
      })
      .reduce((a, p) => {
        if (!a) return p;
        if ((a === 'complete') && (p === 'complete')) return 'complete';
        if ((a === 'none') && (p === 'none')) return 'none';
        return 'some';
      }, null);

    updatePlayerConfig = newConfig => {
      Object.assign(playerConfig, newConfig);
      Pages.applyPagingMode();
      PlayerUI.togglePrintMode();
      PlayerUI.toggleUnitNavButtons();
      PlayerUI.togglePageNavButtons();
    }

    selectDataPartFromUnitState = (unitState, partName) => {
      if (!unitState.dataParts) {
        return [];
      }
      const part = unitState.dataParts[partName] || '[]';
      try {
        return JSON.parse(part);
      } catch (e) {
        console.warn('Could not parse unitState', e);
        return [];
      }
    };

    elementIsRequired = element => element.getAttribute('required') != null &&
      (["", "true"].indexOf(element.getAttribute('required').toLowerCase()) > -1);

    _setUnitData = unitState => {
      Answers.set(this.selectDataPartFromUnitState(unitState, 'answers'));
    };

    _setUnit = unitDef => {
      document.querySelector('#unit').innerHTML = '';
      document.querySelector('#unit').append(document.createRange().createContextualFragment(unitDef));
      Pages.get();
    };

    _setPlayerConfig = newPlayerConfig => {
      playerConfig = Object.assign(playerConfig, newPlayerConfig);
      Pages.applyPagingMode();
      Pages.goto(playerConfig.startPage || 1);
    };
  }

  const Answers = new class {
    status = {};
    _observers = [];

    get = () => {
      const formData = new FormData(document.querySelector("form"));
      const editableFields = Answers._getAnswersFromEditableElements();
      return Object.entries(Answers.status)
        .map(([id, status]) => {
          const values = [...formData.getAll(id), ...(editableFields[id] || [])];
          const value = values.length === 0 ? '' : values.length === 1 ? values[0] : values;
          return { id, status, value };
        });
    }

    set = answers => {
      (answers || []).forEach(answer => {
        Array.isArray(answer.value)
          ? answer.value.forEach((value, index) => this._setAnswer(answer.id, value, index))
          : this._setAnswer(answer.id, answer.value)
      });
    };

    countValid = () => {
      const elements =  [...document.querySelectorAll(PlayerUI.itemElements)];
      let validCount = 0;

      elements.forEach(item => {
        if (!item.isContentEditable) {
          validCount += (!isDefined(item.validity) || item.validity.valid) ? 1 : 0;
        } else {
          validCount += (Unit.elementIsRequired(item) && !item.innerText.trim()) ? 0 : 1;
        }
      });
      // Verona3 wants invalid answers to be ignored. Since semantic validity in the simple player is equivalent
      // to validity in the HTML-sense, empty text-items count always as valid. As a side effect, the responseProgress
      // of 'none' is impossible as long the unit have non-required text-items.
      return validCount;
    };

    countAll = () => [...document.querySelectorAll(PlayerUI.itemElements)].length;

    _getAnswersFromEditableElements = () => ([...document.querySelectorAll('form [contenteditable]')] || [])
      .reduce((carry, element) => {
        const name = element.getAttribute("name") || '';
        carry[name] = (isDefined(carry[name])) ? [...carry[name], element.innerText.trim()] : [element.innerText.trim()];
        return carry;
      }, {});

    _setAnswer = (name, value, index = 0) => {
      // TODO use PlayerUI.itemElements
      const elements = document.querySelectorAll(name
        ? `form [name="${name}"]`
        : "form select:not([name]), form textarea:not([name]), form input:not([name]), form [contenteditable]:not([name])"
      );

      if (elements.length === 0) {
        Log.debug(`form field missing: "${name}"`);
        return;
      }

      if (!Answers.status[name]) {
        Answers.status[name] = "UNSET";
      }
      Answers.status[name] = "VALUE_CHANGED";

      if (Array.isArray(value)) {
        value.forEach((valueEntry, i) => this._setAnswer(name, valueEntry, i));
        return;
      }

      const element = elements[index] || elements[0];

      switch (element.tagName) {
        case "INPUT":
          switch (element.type) {
            case 'radio':
              elements.forEach(radioElem => {
                if (radioElem.value === value) {
                  radioElem.setAttribute('checked', 'checked');
                } else {
                  radioElem.removeAttribute('checked')
                }
              });
              break;
            case 'checkbox':
              if (value === "on") {
                element.setAttribute('checked', 'checked');
              } else {
                element.removeAttribute('checked');
              }
              break;
            default:
              element.setAttribute('value', value);
          }
          break;
        case "SELECT":
          element.querySelector(`option[value="${value}"]`)?.setAttribute('selected', 'on');
          break;
        default:
          element.innerText = value;
      }
    }

    prepare = () => {
      this._cleanObservers();
      document.querySelectorAll(PlayerUI.itemElements)
        .forEach(elem => {
          Answers.status[elem.getAttribute('name') || ''] = 'NOT_REACHED';
          this._newObserver(elem);
        });
    }

    _newObserver = elem => {
      const observer = new IntersectionObserver(
        entries => {
          if (entries[0].isIntersecting) {
            const id = elem.getAttribute('name') || '';
            Answers.status[id] = Answers.status[id] === 'VALUE_CHANGED' ? 'VALUE_CHANGED' : 'DISPLAYED';
            Message.send.vopStateChangedNotification();
          }
        }
      );
      observer.observe(elem);
      this._observers.push(observer);
    }

    setStatusChanged = event => {
      Answers.status[event.target.getAttribute('name') || ''] = 'VALUE_CHANGED';
    }

    _cleanObservers = () => {
      this._observers.forEach(observer => observer.disconnect());
      this._observers.length = 0;
    }
  }

  const Pages = new class {
    _currentPage = 0;
    _observers = [];
    pageCount = 0;
    hasPages = false;
    validPages = {};
    seenPages = {};
    visiblePages = {};

    get = () => {
      const pageElements = document.querySelectorAll("fieldset");
      this.pageCount = Math.max(1, pageElements.length);
      this.hasPages = !!pageElements.length;
      this.validPages = [...pageElements].reduce((carry, pageElement) => {
        const pageNr = 1 + Object.keys(carry).length;
        const legendElem = pageElement.querySelector('legend');
        carry[pageNr.toString()] = (legendElem) ? legendElem.innerText : 'Page-' + pageNr;
        return carry
      }, {});
      this._initPageStates();
    }

    get currentPage() {
      if (!['separate', 'buttons'].includes(playerConfig.pagingMode)) {
        // TODO get first visible page in a better way, ids are not numeric, use find
        const currentPage = Math.min(...Object.keys(this.visiblePages).filter(i => this.visiblePages[i]));
        if (currentPage === Infinity) {
          return 0;
        } else {
          this._currentPage = currentPage;
        }
      }
      return this._currentPage;
    }

    goto = target => {
      if (!this.hasPages) {
        return;
      }

      if (target === '#next') {
        this._currentPage++;
      } else if (target === '#previous') {
        this._currentPage -= 1;
      } else if (target === '#first') {
        this._currentPage = 1;
      } else if (target === '#last') {
        this._currentPage = this.pageCount - 1;
      } else {
        this._currentPage = parseInt(target);
      }

      const pageElem = document.querySelector(`fieldset:nth-of-type(${this._currentPage})`);

      if (['separate', 'buttons'].includes(playerConfig.pagingMode)) {
        this._openPage(pageElem);
        PlayerUI.togglePageNavButtons();
        PlayerUI.removeAllPointers();
        this.seenPages[this._currentPage].enter = true;
        Message.send.vopStateChangedNotification();
      } else {
        pageElem.scrollIntoView({block: 'start', behavior: 'smooth'});
      }
    }

    applyPagingMode = () => {
      document.querySelector('#unit').classList.remove(...pagingModes);
      document.querySelector('#unit').classList.add(playerConfig.pagingMode);
      this._cleanObservers();
      this._setScrollObserver();
    }

    _openPage = pageElem => {
      document.querySelectorAll("fieldset")
        .forEach(fieldsetElement => {fieldsetElement.style.display = 'none'});
      pageElem.style.display = 'block';
    }

    _initPageStates = () => {
      const pageElemType = this.hasPages ? 'fieldset' : '#unit';
      document.querySelectorAll(pageElemType).forEach((pageElem, index) => {
        pageElem.dataset.pagenr = (index + 1).toString(10);
        this.seenPages[pageElem.dataset.pagenr] = {
          enter: !this.hasPages,
          bottom: false
        }
        this.visiblePages[pageElem.dataset.pagenr] = false;
      });
    }

    _setScrollObserver = () => {
      const pageElemType = this.hasPages ? 'fieldset' : '#unit';
      document.querySelectorAll(pageElemType).forEach(pageElem => {
        if (this.hasPages) {
          this._newObserver(this._pageIntersection, pageElem);
        }
        const pageBottomAnchor = document.createElement('div');
        pageElem.appendChild(pageBottomAnchor);
        pageBottomAnchor.classList.add('page-bottom-anchor');
        this._newObserver(this._pageBottomIntersection, pageBottomAnchor);
      });
    }

    _newObserver = (callback, elem) => {
      const observer = new IntersectionObserver(
        entries => entries.forEach(callback),
        {
          root: document.querySelector('#unit'),
          threshold: 0.01,
          rootMargin: '0%'
        }
      );
      observer.observe(elem);
      this._observers.push(observer);
    }

    _pageIntersection = intersectionEntry => {
      const pageId = parseInt(intersectionEntry.target.dataset.pagenr, 10);
      if (!['separate', 'buttons'].includes(playerConfig.pagingMode)) {
        this.visiblePages[pageId] = intersectionEntry.isIntersecting;
      }
      this.seenPages[pageId].enter = this.seenPages[pageId].enter || intersectionEntry.isIntersecting;
      Message.send.vopStateChangedNotification();
    }

    _pageBottomIntersection = intersectionEntry => {
      if (!intersectionEntry.isIntersecting) {
        return;
      }
      const pageId = parseInt(intersectionEntry.target.parentElement.dataset.pagenr, 10);
      this.seenPages[pageId].bottom = true;
      Message.send.vopStateChangedNotification();
    }

    _cleanObservers = () => {
      this._observers.forEach(observer => observer.disconnect());
      this._observers.length = 0;
    }
  }


  const Log = new class {
    _logStash = {
      sent: [],
      new: []
    };

    debug = message => {
      console.warn(message);
      if (playerConfig.logPolicy === "debug") {
        this._log('debug', message);
      }
    }

    rich = (type, message) => {
      if (["debug", "rich"].indexOf(playerConfig.logPolicy) > -1) {
        this._log(type, message);
      }
    }

    lean = (type, message) => {
      if (["debug", "rich", "lean"].indexOf(playerConfig.logPolicy) > -1) {
        this._log(type, message);
      }
    }

    getAll = () => [...this._logStash.sent.map(msg => {msg.sent = true; return msg}), ...this._logStash.new];

    next = () => {
      const toSent = [...this._logStash.new];
      this._logStash.sent.push(...toSent);
      this._logStash.new.length = 0
      return toSent;
    }

    hasNew = () => (this._logStash.new.length > 0);

    _log = (type, message) => {
      this._logStash.new.push({
        timeStamp: Date.now(),
        key: type,
        content: message
      });
      Message.send.vopStateChangedNotification();
      document.dispatchEvent(new CustomEvent('updateLog'));
    }
  };

  const PlayerUI = new class {
    itemElements = "form select:enabled, form textarea:enabled, form input:enabled, form [contenteditable]";
    presentationReportFactors = {
      pages: () => this._createPresentationReportForPages()
    }

    toggleButton = (buttonId, enabled, visible = true) => {
      const button = document.querySelector(`#${buttonId}`);
      if (button) {
        if (enabled) {
          button.removeAttribute("disabled");
        } else {
          button.setAttribute("disabled", "true");
        }
        button.style.display = visible ? 'inline-block' : 'none';
      }
    }

    togglePageNavButtons = () => {
      document.querySelector('#unit').classList[Pages.hasPages ? 'add' : 'remove']('paged');
      this.toggleButton('next-page',
        Pages.pageCount > 1 && Pages.currentPage < Pages.pageCount,
        Pages.pageCount > 1 && playerConfig.pagingMode === 'buttons'
      );
      this.toggleButton('prev-page',
        Pages.pageCount > 1 && Pages.currentPage > 1,
        Pages.pageCount > 1 && playerConfig.pagingMode === 'buttons'
      );
    }

    toggleUnitNavButtons = () => {
      this.toggleButton('first-unit', playerConfig.enabledNavigationTargets.indexOf('first') > -1);
      this.toggleButton('prev-unit', playerConfig.enabledNavigationTargets.indexOf('previous') > -1);
      this.toggleButton('next-unit', playerConfig.enabledNavigationTargets.indexOf('next') > -1);
      this.toggleButton('last-unit', playerConfig.enabledNavigationTargets.indexOf('last') > -1);
      this.toggleButton('end-unit', playerConfig.enabledNavigationTargets.indexOf('end') > -1);
    }

    togglePrintMode = () => {
      document.querySelector('#print-styles').setAttribute('media', 'print')
      document.querySelectorAll('vsp-namehint')
        .forEach(element => element.parentNode.removeChild(element));
      switch(playerConfig.printMode) {
        case 'on-with-ids':
          document.querySelectorAll('#unit [name]')
            .forEach(elem => elem.outerHTML += `<vsp-namehint>${elem.name}</vsp-namehint>`);
        case 'on':
          document.querySelector('#print-styles').removeAttribute('media');
      }
    }

    getPlayerInfoHTML = () => {
      const infoBoxElem = document.createElement('div');
      infoBoxElem.id = 'vsp-meta';
      infoBoxElem.innerHTML = `
        <h1>${playerMetaData.name[0].value} ${playerMetaData.version}</h1>
        <p>${playerMetaData.description[0].value}</p>
        <dl>
          <dt>Maintainer</dt>
          <dd>
            <a href="${playerMetaData.maintainer.url}" target="_blank">${playerMetaData.maintainer.name[0].value}</a>
            <a href="mailto:${playerMetaData.maintainer.email}">Email</a>
          </dd>
          <dt>Verona-Version</dt>
          <dd>${playerMetaData.specVersion}</dd>
          <dt>Repository</dt>
          <dd><a href="${playerMetaData.code.repositoryUrl}">${playerMetaData.code.repositoryType}</a></dd>
          <dt>License</dt>
          <dd><a href="${playerMetaData.code.licenseUrl}">${playerMetaData.code.licenseType}</a></dd>
        </dl>
      `;
      return infoBoxElem;
    }

    preventFromImplicitSubmission = event => {
      const keyCode = event.charCode || event.keyCode || 0;
      if (keyCode === 13) {
        event.preventDefault();
      }
    }

    navigationDeniedMessage = reasons => {
      let message = '<div><b>Navigation denied</b></div>';
      if (reasons.indexOf('responsesIncomplete') !== -1) {
        message += this._createValidationReport();
      }
      if (reasons.indexOf('presentationIncomplete') !== -1) {
        message += this._createPresentationReport();
      }
      PlayerUI.toggleMessage(message);
    }

    _createValidationReport = () =>
      [...document.querySelectorAll(PlayerUI.itemElements)]
        .filter(element => element.checkValidity || element.isContentEditable)
        .map(element => {
          if (element.checkValidity) {
            element.checkValidity();
            return {
              label: element.labels.length ? element.labels[0].innerText : element.name,
              name: element.name,
              message: element.validationMessage
            }
          }
          if (element.isContentEditable && Unit.elementIsRequired(element) && !element.innerText.trim()) {
            return {
              label: element.getAttribute('name') ?? "Editable Element",
              name: element.getAttribute('name') ?? '',
              message: "Has no content"
            }
          }
          return false;
        })
        .filter(entry => entry.message)
        .map(e =>
          `<div onclick="PlayerUI.highlightElements('${e.name}')">${e.label}: ${e.message}</div>`
        )
        .join('');

    highlightElements = name => {
      // TODO nameless elements can not be highlighted
      this.removeAllPointers();
      this.gotoElement(`[name='${name}']`);
      setTimeout(() => this.addPointers(`[name='${name}']`), 15);
    }

    gotoElement = selector => {
      const element = document.querySelector(selector);
      if (!element) {
        return;
      }
      const page = element.closest('fieldset').dataset.pagenr;
      if (page) {
        Pages.goto(page);
      }
      element.scrollIntoView();
    }

    addPointers = selector => {
      const body = document.querySelector('body');
      document.querySelectorAll(selector)
        .forEach(element => {
          const rect = element.getBoundingClientRect();
          const x = Math.round(rect.left - 30);
          const y = Math.round(rect.top + (rect.height / 2) - 15);
          const vspPointer = document.createElement('vsp-pointer');
          vspPointer.style = `left:${x}px; top:${y}px`;
          body.appendChild(vspPointer);
        });
      document.querySelector('#unit').addEventListener('scroll', PlayerUI.removeAllPointers);
    }

    removeAllPointers = () => {
      document.querySelectorAll(`vsp-pointer`)
        .forEach(element => element.parentElement.removeChild(element));
      document.querySelector('#unit').removeEventListener('scroll', PlayerUI.removeAllPointers);
    }

    _createPresentationReport = () =>
      Object.values(this.presentationReportFactors)
        .flatMap(reportFunction => reportFunction())
        .filter(row => row)
        .join('');

    _createPresentationReportForPages = () =>
      Object.keys(Pages.seenPages)
        .map(pageNr => {
          const msg = `<div onclick="Pages.goto('${pageNr}')">${Pages.validPages[pageNr]}: `;
          if (Pages.seenPages[pageNr].enter && !Pages.seenPages[pageNr].bottom) {
            return msg + `Scroll down to see everything</div>`;
          }
          if (!Pages.seenPages[pageNr].enter) {
            return msg + `Page was not entered</div>`;
          }
          return "";
        });

    addEventListener = (eventName, selector, listener) => {
      document.querySelector('body').addEventListener(eventName, event => {
        if (event.target.matches(selector)) {
          listener(event);
        }
      });
    }

    toggleMessage = (content, isError) => {
      const dialog = document.querySelector('vsp-message');
      const dialogContent = document.querySelector('vsp-message-content');
      if (!content) {
        dialog.style.display = 'none';
        this.removeAllPointers();
      } else {
        dialogContent.innerHTML = content;
        dialog.style.display = 'block';
        dialog.classList[isError ? 'add' : 'remove']('error');
      }
    }
  }

  class VspRuntimeError extends Error {
    name = 'VspRuntimeError';
    constructor(code, message) {
      super(message);
      this.code = code;
    }
  }

  window.addEventListener('message', event => {Message.receive(event.data.type, event.data)}, false);

  window.addEventListener('error', event => {
    if (event.error.name === VspRuntimeError.name) {
      Message.send.vopRuntimeErrorNotification(event.error.code, event.error.message);
      PlayerUI.toggleMessage('Error: ' + event.error.message, true);
    } else {
      Message.send.vopRuntimeErrorNotification('runtime-error', event.error.message);
      PlayerUI.toggleMessage('Error: Runtime Error', true);
    }
  }, false);

  document.addEventListener("DOMContentLoaded", Message.send.vopReadyNotification);

  document.addEventListener("vopPageNavigationCommand", event => Pages.goto(event.detail.target));
  document.addEventListener("vopNavigationDeniedNotification", event => PlayerUI.navigationDeniedMessage(event.detail.reason));

  document.addEventListener("vopPlayerConfigChangedNotification", event => {
    Unit.updatePlayerConfig(event.detail.playerConfig);
  });

  window.addEventListener('blur', () => {
    Message.send.vopWindowFocusChangedNotification(document.hasFocus());
  });

  window.addEventListener('focus', () => {
    Message.send.vopWindowFocusChangedNotification(document.hasFocus());
  });

  PlayerUI.addEventListener('keypress', PlayerUI.itemElements, PlayerUI.preventFromImplicitSubmission);

  PlayerUI.addEventListener('change', PlayerUI.itemElements, Message.send.vopStateChangedNotification);
  PlayerUI.addEventListener('programmaticallyChange', PlayerUI.itemElements, Message.send.vopStateChangedNotification);
  PlayerUI.addEventListener('keyup', PlayerUI.itemElements,
    Time.debounce(Message.send.vopStateChangedNotification, parseInt(playerSettings.debounceKeyboardEvents), 10)
  );

  PlayerUI.addEventListener('change', PlayerUI.itemElements, Answers.setStatusChanged);
  PlayerUI.addEventListener('programmaticallyChange', PlayerUI.itemElements, Answers.setStatusChanged);
  PlayerUI.addEventListener('keyup', PlayerUI.itemElements, Answers.setStatusChanged);

  PlayerUI.addEventListener('click', '#next-page', () => Pages.goto('#next'));
  PlayerUI.addEventListener('click', '#prev-page', () => Pages.goto('#previous'));

  PlayerUI.addEventListener('click', '#prev-unit', () => {
    Message.send.vopUnitNavigationRequestedNotification("previous");
  });
  PlayerUI.addEventListener('click', '#next-unit', () => {
    Message.send.vopUnitNavigationRequestedNotification("next");
  });
  PlayerUI.addEventListener('click', '#first-unit', () => {
    Message.send.vopUnitNavigationRequestedNotification("first");
  });
  PlayerUI.addEventListener('click', '#last-unit', () => {
    Message.send.vopUnitNavigationRequestedNotification("last");
  });
  PlayerUI.addEventListener('click', '#end-unit', () => {
    Message.send.vopUnitNavigationRequestedNotification("end");
  });
  PlayerUI.addEventListener('click', 'vsp-message-close', () => {
    PlayerUI.toggleMessage();
  });

  // make the player globally available for tests/extensions
  window.vsp = { PlayerUI, Message, Pages, Log };
</script>

</body>
</html>
